{"ast":null,"code":"export const amSuffix = ' AM';\nexport const pmSuffix = ' PM';\nexport const makeTimeOptions = (stepMinutes, hour12, delimiter) => {\n  const res = [];\n  const iter = new Date(new Date().setHours(0, 0, 0, 0));\n  const iterDay = iter.getDay();\n\n  while (iter.getDay() === iterDay) {\n    let hour = iter.getHours();\n    let suffix = amSuffix;\n\n    if (hour12) {\n      if (hour === 0) {\n        hour = 12; // 12am\n      } else if (hour >= 12) {\n        suffix = pmSuffix;\n      }\n\n      if (hour > 12) {\n        hour %= 12;\n      }\n    }\n\n    res.push((hour12 ? hour.toString() : hour.toString().padStart(2, '0')) + delimiter + iter.getMinutes().toString().padStart(2, '0') + (hour12 ? suffix : ''));\n    iter.setMinutes(iter.getMinutes() + stepMinutes);\n  }\n\n  return res;\n};\nexport const parseTime = (time, timeRegex, delimiter, is12Hour) => {\n  const date = new Date(time); // if default time is a ISO 8601 formatted date string, we parse it to hh:mm(am/pm) format\n\n  if (!isNaN(date.getDate()) && (time instanceof Date || time.includes('T'))) {\n    const hours = is12Hour ? `${date.getHours() > 12 ? date.getHours() - 12 : date.getHours()}` : `${date.getHours()}`.padStart(2, '0');\n    const minutes = `${date.getMinutes()}`.padStart(2, '0');\n    let ampm = '';\n\n    if (is12Hour && date.getHours() > 11) {\n      ampm = pmSuffix;\n    } else if (is12Hour) {\n      ampm = amSuffix;\n    }\n\n    return `${hours}${delimiter}${minutes}${ampm}`;\n  } else if (typeof time === 'string') {\n    time = time.trim();\n\n    if (is12Hour && time !== '' && validateTime(time, timeRegex, delimiter, is12Hour)) {\n      // Format AM/PM according to design\n      let ampm = '';\n\n      if (time.toUpperCase().includes(amSuffix.toUpperCase().trim())) {\n        time = time.toUpperCase().replace(amSuffix.toUpperCase().trim(), '').trim();\n        ampm = amSuffix;\n      } else if (time.toUpperCase().includes(pmSuffix.toUpperCase().trim())) {\n        time = time.toUpperCase().replace(pmSuffix.toUpperCase().trim(), '').trim();\n        ampm = pmSuffix;\n      } else {\n        // if this 12 hour time is missing am/pm but otherwise valid,\n        // append am/pm depending on time of day\n        ampm = new Date().getHours() > 11 ? pmSuffix : amSuffix;\n      }\n\n      return `${time}${ampm}`;\n    }\n  }\n\n  return time.toString();\n};\nexport const validateTime = (time, timeRegex, delimiter, is12Hour) => {\n  // ISO 8601 format is valid\n  const date = new Date(time);\n\n  if (!isNaN(date.getDate()) && time.includes('T')) {\n    return true;\n  } // hours only valid if they are [0-23] or [0-12]\n\n\n  const hours = parseInt(time.split(delimiter)[0]);\n  const validHours = hours >= 0 && hours <= (is12Hour ? 12 : 23); // minutes verified by timeRegex\n  // empty string is valid\n\n  return time === '' || timeRegex.test(time) && validHours;\n};\nexport const getHours = (time, timeRegex) => {\n  const parts = time.match(timeRegex);\n\n  if (parts && parts.length) {\n    return /am/i.test(parts[4]) ? parseInt(parts[1]) : parseInt(parts[1]) + 12;\n  }\n\n  return null;\n};\nexport const getMinutes = (time, timeRegex) => {\n  const parts = time.match(timeRegex);\n  return parts && parts.length ? parseInt(parts[2]) : null;\n};","map":{"version":3,"sources":["../../../../src/components/TimePicker/TimePickerUtils.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["export const amSuffix = ' AM';\nexport const pmSuffix = ' PM';\nexport const makeTimeOptions = (stepMinutes, hour12, delimiter) => {\n    const res = [];\n    const iter = new Date(new Date().setHours(0, 0, 0, 0));\n    const iterDay = iter.getDay();\n    while (iter.getDay() === iterDay) {\n        let hour = iter.getHours();\n        let suffix = amSuffix;\n        if (hour12) {\n            if (hour === 0) {\n                hour = 12; // 12am\n            }\n            else if (hour >= 12) {\n                suffix = pmSuffix;\n            }\n            if (hour > 12) {\n                hour %= 12;\n            }\n        }\n        res.push((hour12 ? hour.toString() : hour.toString().padStart(2, '0')) +\n            delimiter +\n            iter\n                .getMinutes()\n                .toString()\n                .padStart(2, '0') +\n            (hour12 ? suffix : ''));\n        iter.setMinutes(iter.getMinutes() + stepMinutes);\n    }\n    return res;\n};\nexport const parseTime = (time, timeRegex, delimiter, is12Hour) => {\n    const date = new Date(time);\n    // if default time is a ISO 8601 formatted date string, we parse it to hh:mm(am/pm) format\n    if (!isNaN(date.getDate()) && (time instanceof Date || time.includes('T'))) {\n        const hours = is12Hour\n            ? `${date.getHours() > 12 ? date.getHours() - 12 : date.getHours()}`\n            : `${date.getHours()}`.padStart(2, '0');\n        const minutes = `${date.getMinutes()}`.padStart(2, '0');\n        let ampm = '';\n        if (is12Hour && date.getHours() > 11) {\n            ampm = pmSuffix;\n        }\n        else if (is12Hour) {\n            ampm = amSuffix;\n        }\n        return `${hours}${delimiter}${minutes}${ampm}`;\n    }\n    else if (typeof time === 'string') {\n        time = time.trim();\n        if (is12Hour && time !== '' && validateTime(time, timeRegex, delimiter, is12Hour)) {\n            // Format AM/PM according to design\n            let ampm = '';\n            if (time.toUpperCase().includes(amSuffix.toUpperCase().trim())) {\n                time = time\n                    .toUpperCase()\n                    .replace(amSuffix.toUpperCase().trim(), '')\n                    .trim();\n                ampm = amSuffix;\n            }\n            else if (time.toUpperCase().includes(pmSuffix.toUpperCase().trim())) {\n                time = time\n                    .toUpperCase()\n                    .replace(pmSuffix.toUpperCase().trim(), '')\n                    .trim();\n                ampm = pmSuffix;\n            }\n            else {\n                // if this 12 hour time is missing am/pm but otherwise valid,\n                // append am/pm depending on time of day\n                ampm = new Date().getHours() > 11 ? pmSuffix : amSuffix;\n            }\n            return `${time}${ampm}`;\n        }\n    }\n    return time.toString();\n};\nexport const validateTime = (time, timeRegex, delimiter, is12Hour) => {\n    // ISO 8601 format is valid\n    const date = new Date(time);\n    if (!isNaN(date.getDate()) && time.includes('T')) {\n        return true;\n    }\n    // hours only valid if they are [0-23] or [0-12]\n    const hours = parseInt(time.split(delimiter)[0]);\n    const validHours = hours >= 0 && hours <= (is12Hour ? 12 : 23);\n    // minutes verified by timeRegex\n    // empty string is valid\n    return time === '' || (timeRegex.test(time) && validHours);\n};\nexport const getHours = (time, timeRegex) => {\n    const parts = time.match(timeRegex);\n    if (parts && parts.length) {\n        return /am/i.test(parts[4]) ? parseInt(parts[1]) : parseInt(parts[1]) + 12;\n    }\n    return null;\n};\nexport const getMinutes = (time, timeRegex) => {\n    const parts = time.match(timeRegex);\n    return parts && parts.length ? parseInt(parts[2]) : null;\n};\n//# sourceMappingURL=TimePickerUtils.js.map"]},"metadata":{},"sourceType":"module"}