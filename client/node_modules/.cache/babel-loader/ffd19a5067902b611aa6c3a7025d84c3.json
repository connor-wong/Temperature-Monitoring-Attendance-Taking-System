{"ast":null,"code":"import { viewport } from '../enums';\nimport getViewportRect from './getViewportRect';\nimport getDocumentRect from './getDocumentRect';\nimport listScrollParents from './listScrollParents';\nimport getOffsetParent from './getOffsetParent';\nimport getDocumentElement from './getDocumentElement';\nimport getComputedStyle from './getComputedStyle';\nimport { isElement, isHTMLElement } from './instanceOf';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getParentNode from './getParentNode';\nimport contains from './contains';\nimport getNodeName from './getNodeName';\nimport rectToClientRect from '../utils/rectToClientRect';\n/**\n * @param element\n */\n\nfunction getInnerBoundingClientRect(element) {\n  const rect = getBoundingClientRect(element);\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n/**\n * @param element\n * @param clippingParent\n */\n\n\nfunction getClientRectFromMixedType(element, clippingParent) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n/**\n * @param element\n */\n\n\nfunction getClippingParents(element) {\n  const clippingParents = listScrollParents(getParentNode(element));\n  const canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(clippingParent => isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n/**\n * @param element\n * @param boundary\n * @param rootBoundary\n */\n\n\nexport default function getClippingRect(element, boundary, rootBoundary) {\n  const mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  const clippingParents = [...mainClippingParents, rootBoundary];\n  const firstClippingParent = clippingParents[0];\n  const clippingRect = clippingParents.reduce((accRect, clippingParent) => {\n    const rect = getClientRectFromMixedType(element, clippingParent);\n    accRect.top = Math.max(rect.top, accRect.top);\n    accRect.right = Math.min(rect.right, accRect.right);\n    accRect.bottom = Math.min(rect.bottom, accRect.bottom);\n    accRect.left = Math.max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}","map":{"version":3,"sources":["../../../../../../../src/helpers/Popper/thirdparty/popper-core/dom-utils/getClippingRect.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { viewport } from '../enums';\nimport getViewportRect from './getViewportRect';\nimport getDocumentRect from './getDocumentRect';\nimport listScrollParents from './listScrollParents';\nimport getOffsetParent from './getOffsetParent';\nimport getDocumentElement from './getDocumentElement';\nimport getComputedStyle from './getComputedStyle';\nimport { isElement, isHTMLElement } from './instanceOf';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getParentNode from './getParentNode';\nimport contains from './contains';\nimport getNodeName from './getNodeName';\nimport rectToClientRect from '../utils/rectToClientRect';\n/**\n * @param element\n */\nfunction getInnerBoundingClientRect(element) {\n    const rect = getBoundingClientRect(element);\n    rect.top = rect.top + element.clientTop;\n    rect.left = rect.left + element.clientLeft;\n    rect.bottom = rect.top + element.clientHeight;\n    rect.right = rect.left + element.clientWidth;\n    rect.width = element.clientWidth;\n    rect.height = element.clientHeight;\n    rect.x = rect.left;\n    rect.y = rect.top;\n    return rect;\n}\n/**\n * @param element\n * @param clippingParent\n */\nfunction getClientRectFromMixedType(element, clippingParent) {\n    return clippingParent === viewport\n        ? rectToClientRect(getViewportRect(element))\n        : isHTMLElement(clippingParent)\n            ? getInnerBoundingClientRect(clippingParent)\n            : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n}\n// A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n/**\n * @param element\n */\nfunction getClippingParents(element) {\n    const clippingParents = listScrollParents(getParentNode(element));\n    const canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n    const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n    if (!isElement(clipperElement)) {\n        return [];\n    }\n    // $FlowFixMe: https://github.com/facebook/flow/issues/1414\n    return clippingParents.filter(clippingParent => isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body');\n}\n// Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n/**\n * @param element\n * @param boundary\n * @param rootBoundary\n */\nexport default function getClippingRect(element, boundary, rootBoundary) {\n    const mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n    const clippingParents = [...mainClippingParents, rootBoundary];\n    const firstClippingParent = clippingParents[0];\n    const clippingRect = clippingParents.reduce((accRect, clippingParent) => {\n        const rect = getClientRectFromMixedType(element, clippingParent);\n        accRect.top = Math.max(rect.top, accRect.top);\n        accRect.right = Math.min(rect.right, accRect.right);\n        accRect.bottom = Math.min(rect.bottom, accRect.bottom);\n        accRect.left = Math.max(rect.left, accRect.left);\n        return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n}\n//# sourceMappingURL=getClippingRect.js.map"]},"metadata":{},"sourceType":"module"}