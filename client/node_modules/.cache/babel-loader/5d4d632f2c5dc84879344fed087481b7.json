{"ast":null,"code":"// @ts-nocheck\nimport { top, left, right, bottom, start } from '../enums';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport getAltAxis from '../utils/getAltAxis';\nimport within from '../utils/within';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport detectOverflow from '../utils/detectOverflow';\nimport getVariation from '../utils/getVariation';\nimport getFreshSideObject from '../utils/getFreshSideObject';\n/**\n *\n */\n\nfunction preventOverflow({\n  state,\n  options,\n  name\n}) {\n  const {\n    mainAxis: checkMainAxis = true,\n    altAxis: checkAltAxis = false,\n    boundary,\n    rootBoundary,\n    altBoundary,\n    padding,\n    tether = true,\n    tetherOffset = 0\n  } = options;\n  const overflow = detectOverflow(state, {\n    boundary,\n    rootBoundary,\n    padding,\n    altBoundary\n  });\n  const basePlacement = getBasePlacement(state.placement);\n  const variation = getVariation(state.placement);\n  const isBasePlacement = !variation;\n  const mainAxis = getMainAxisFromPlacement(basePlacement);\n  const altAxis = getAltAxis(mainAxis);\n  const popperOffsets = state.modifiersData.popperOffsets;\n  const referenceRect = state.rects.reference;\n  const popperRect = state.rects.popper;\n  const tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign(Object.assign({}, state.rects), {\n    placement: state.placement\n  })) : tetherOffset;\n  const data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    const mainSide = mainAxis === 'y' ? top : left;\n    const altSide = mainAxis === 'y' ? bottom : right;\n    const len = mainAxis === 'y' ? 'height' : 'width';\n    const offset = popperOffsets[mainAxis];\n    const min = popperOffsets[mainAxis] + overflow[mainSide];\n    const max = popperOffsets[mainAxis] - overflow[altSide];\n    const additive = tether ? -popperRect[len] / 2 : 0;\n    const minLen = variation === start ? referenceRect[len] : popperRect[len];\n    const maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    const arrowElement = state.elements.arrow;\n    const arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    const arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    const arrowPaddingMin = arrowPaddingObject[mainSide];\n    const arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    const arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    const minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    const maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n    const arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    const clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    const offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n    const tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n    const tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n    const preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    const mainSide = mainAxis === 'x' ? top : left;\n    const altSide = mainAxis === 'x' ? bottom : right;\n    const offset = popperOffsets[altAxis];\n    const min = offset + overflow[mainSide];\n    const max = offset - overflow[altSide];\n    const preventedOffset = within(min, offset, max);\n    popperOffsets[altAxis] = preventedOffset;\n    data[altAxis] = preventedOffset - offset;\n  }\n\n  state.modifiersData[name] = data;\n}\n\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};","map":{"version":3,"sources":["../../../../../../../src/helpers/Popper/thirdparty/popper-core/modifiers/preventOverflow.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// @ts-nocheck\nimport { top, left, right, bottom, start } from '../enums';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport getAltAxis from '../utils/getAltAxis';\nimport within from '../utils/within';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport detectOverflow from '../utils/detectOverflow';\nimport getVariation from '../utils/getVariation';\nimport getFreshSideObject from '../utils/getFreshSideObject';\n/**\n *\n */\nfunction preventOverflow({ state, options, name }) {\n    const { mainAxis: checkMainAxis = true, altAxis: checkAltAxis = false, boundary, rootBoundary, altBoundary, padding, tether = true, tetherOffset = 0 } = options;\n    const overflow = detectOverflow(state, {\n        boundary,\n        rootBoundary,\n        padding,\n        altBoundary\n    });\n    const basePlacement = getBasePlacement(state.placement);\n    const variation = getVariation(state.placement);\n    const isBasePlacement = !variation;\n    const mainAxis = getMainAxisFromPlacement(basePlacement);\n    const altAxis = getAltAxis(mainAxis);\n    const popperOffsets = state.modifiersData.popperOffsets;\n    const referenceRect = state.rects.reference;\n    const popperRect = state.rects.popper;\n    const tetherOffsetValue = typeof tetherOffset === 'function'\n        ? tetherOffset(Object.assign(Object.assign({}, state.rects), { placement: state.placement }))\n        : tetherOffset;\n    const data = { x: 0, y: 0 };\n    if (!popperOffsets) {\n        return;\n    }\n    if (checkMainAxis) {\n        const mainSide = mainAxis === 'y' ? top : left;\n        const altSide = mainAxis === 'y' ? bottom : right;\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const offset = popperOffsets[mainAxis];\n        const min = popperOffsets[mainAxis] + overflow[mainSide];\n        const max = popperOffsets[mainAxis] - overflow[altSide];\n        const additive = tether ? -popperRect[len] / 2 : 0;\n        const minLen = variation === start ? referenceRect[len] : popperRect[len];\n        const maxLen = variation === start ? -popperRect[len] : -referenceRect[len];\n        // We need to include the arrow in the calculation so the arrow doesn't go\n        // outside the reference bounds\n        const arrowElement = state.elements.arrow;\n        const arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : { width: 0, height: 0 };\n        const arrowPaddingObject = state.modifiersData['arrow#persistent']\n            ? state.modifiersData['arrow#persistent'].padding\n            : getFreshSideObject();\n        const arrowPaddingMin = arrowPaddingObject[mainSide];\n        const arrowPaddingMax = arrowPaddingObject[altSide];\n        // If the reference length is smaller than the arrow length, we don't want\n        // to include its full size in the calculation. If the reference is small\n        // and near the edge of a boundary, the popper can overflow even if the\n        // reference is not overflowing as well (e.g. virtual elements with no\n        // width or height)\n        const arrowLen = within(0, referenceRect[len], arrowRect[len]);\n        const minOffset = isBasePlacement\n            ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue\n            : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n        const maxOffset = isBasePlacement\n            ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue\n            : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n        const arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n        const clientOffset = arrowOffsetParent\n            ? mainAxis === 'y'\n                ? arrowOffsetParent.clientTop || 0\n                : arrowOffsetParent.clientLeft || 0\n            : 0;\n        const offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n        const tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n        const tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n        const preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);\n        popperOffsets[mainAxis] = preventedOffset;\n        data[mainAxis] = preventedOffset - offset;\n    }\n    if (checkAltAxis) {\n        const mainSide = mainAxis === 'x' ? top : left;\n        const altSide = mainAxis === 'x' ? bottom : right;\n        const offset = popperOffsets[altAxis];\n        const min = offset + overflow[mainSide];\n        const max = offset - overflow[altSide];\n        const preventedOffset = within(min, offset, max);\n        popperOffsets[altAxis] = preventedOffset;\n        data[altAxis] = preventedOffset - offset;\n    }\n    state.modifiersData[name] = data;\n}\nexport default {\n    name: 'preventOverflow',\n    enabled: true,\n    phase: 'main',\n    fn: preventOverflow,\n    requiresIfExists: ['offset']\n};\n//# sourceMappingURL=preventOverflow.js.map"]},"metadata":{},"sourceType":"module"}