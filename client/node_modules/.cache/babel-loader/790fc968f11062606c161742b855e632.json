{"ast":null,"code":"import * as ReactDOM from 'react-dom';\nimport { SIDE } from './constants';\n/**\n * @param {string} input - String to capitalize first letter\n */\n\nexport function capitalize(input) {\n  return input[0].toUpperCase() + input.substring(1);\n}\n/**\n * @param {string} prefix - String to prefix ID with\n */\n\nexport function getUniqueId(prefix = 'pf') {\n  const uid = new Date().getTime() + Math.random().toString(36).slice(2);\n  return `${prefix}-${uid}`;\n}\n/**\n * @param { any } this - \"This\" reference\n * @param { Function } func - Function to debounce\n * @param { number } wait - Debounce amount\n */\n\nexport function debounce(func, wait) {\n  let timeout;\n  return (...args) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(this, args), wait);\n  };\n}\n/** This function returns whether or not an element is within the viewable area of a container. If partial is true,\n * then this function will return true even if only part of the element is in view.\n *\n * @param {HTMLElement} container  The container to check if the element is in view of.\n * @param {HTMLElement} element    The element to check if it is view\n * @param {boolean} partial   true if partial view is allowed\n *\n * @returns { boolean } True if the component is in View.\n */\n\nexport function isElementInView(container, element, partial) {\n  if (!container || !element) {\n    return false;\n  }\n\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.floor(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.floor(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right); // Check if in view\n\n  const isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;\n  const isPartiallyInView = partial && (elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft || elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight); // Return outcome\n\n  return isTotallyInView || isPartiallyInView;\n}\n/** This function returns the side the element is out of view on (right, left or both)\n *\n * @param {HTMLElement} container    The container to check if the element is in view of.\n * @param {HTMLElement} element      The element to check if it is view\n *\n * @returns {string} right if the element is of the right, left if element is off the left or both if it is off on both sides.\n */\n\nexport function sideElementIsOutOfView(container, element) {\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.floor(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.floor(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right); // Check if in view\n\n  const isOffLeft = elementBoundsLeft < containerBoundsLeft;\n  const isOffRight = elementBoundsRight > containerBoundsRight;\n  let side = SIDE.NONE;\n\n  if (isOffRight && isOffLeft) {\n    side = SIDE.BOTH;\n  } else if (isOffRight) {\n    side = SIDE.RIGHT;\n  } else if (isOffLeft) {\n    side = SIDE.LEFT;\n  } // Return outcome\n\n\n  return side;\n}\n/** Interpolates a parameterized templateString using values from a templateVars object.\n * The templateVars object should have keys and values which match the templateString's parameters.\n * Example:\n *    const templateString: 'My name is ${firstName} ${lastName}';\n *    const templateVars: {\n *      firstName: 'Jon'\n *      lastName: 'Dough'\n *    };\n *    const result = fillTemplate(templateString, templateVars);\n *    // \"My name is Jon Dough\"\n *\n * @param {string} templateString  The string passed by the consumer\n * @param {object} templateVars The variables passed to the string\n *\n * @returns {string} The template string literal result\n */\n\nexport function fillTemplate(templateString, templateVars) {\n  return templateString.replace(/\\${(.*?)}/g, (_, match) => templateVars[match] || '');\n}\n/**\n * This function allows for keyboard navigation through dropdowns. The custom argument is optional.\n *\n * @param {number} index The index of the element you're on\n * @param {number} innerIndex Inner index number\n * @param {string} position The orientation of the dropdown\n * @param {string[]} refsCollection Array of refs to the items in the dropdown\n * @param {object[]} kids Array of items in the dropdown\n * @param {boolean} [custom] Allows for handling of flexible content\n */\n\nexport function keyHandler(index, innerIndex, position, refsCollection, kids, custom = false) {\n  if (!Array.isArray(kids)) {\n    return;\n  }\n\n  const isMultiDimensional = refsCollection.filter(ref => ref)[0].constructor === Array;\n  let nextIndex = index;\n  let nextInnerIndex = innerIndex;\n\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = kids.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (position === 'down') {\n    if (index === kids.length - 1) {\n      // loop back to beginning\n      nextIndex = 0;\n    } else {\n      nextIndex = index + 1;\n    }\n  } else if (position === 'left') {\n    if (innerIndex === 0) {\n      nextInnerIndex = refsCollection[index].length - 1;\n    } else {\n      nextInnerIndex = innerIndex - 1;\n    }\n  } else if (position === 'right') {\n    if (innerIndex === refsCollection[index].length - 1) {\n      nextInnerIndex = 0;\n    } else {\n      nextInnerIndex = innerIndex + 1;\n    }\n  }\n\n  if (refsCollection[nextIndex] === null || refsCollection[nextIndex] === undefined || isMultiDimensional && (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === undefined)) {\n    keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);\n  } else if (custom) {\n    if (refsCollection[nextIndex].focus) {\n      refsCollection[nextIndex].focus();\n    } // eslint-disable-next-line react/no-find-dom-node\n\n\n    const element = ReactDOM.findDOMNode(refsCollection[nextIndex]);\n    element.focus();\n  } else if (position !== 'tab') {\n    if (isMultiDimensional) {\n      refsCollection[nextIndex][nextInnerIndex].focus();\n    } else {\n      refsCollection[nextIndex].focus();\n    }\n  }\n}\n/** This function is a helper for keyboard navigation through dropdowns.\n *\n * @param {number} index The index of the element you're on\n * @param {string} position The orientation of the dropdown\n * @param {string[]} collection Array of refs to the items in the dropdown\n */\n\nexport function getNextIndex(index, position, collection) {\n  let nextIndex;\n\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = collection.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (index === collection.length - 1) {\n    // loop back to beginning\n    nextIndex = 0;\n  } else {\n    nextIndex = index + 1;\n  }\n\n  if (collection[nextIndex] === undefined || collection[nextIndex][0] === null) {\n    return getNextIndex(nextIndex, position, collection);\n  } else {\n    return nextIndex;\n  }\n}\n/** This function is a helper for pluralizing strings.\n *\n * @param {number} i The quantity of the string you want to pluralize\n * @param {string} singular The singular version of the string\n * @param {string} plural The change to the string that should occur if the quantity is not equal to 1.\n *                 Defaults to adding an 's'.\n */\n\nexport function pluralize(i, singular, plural) {\n  if (!plural) {\n    plural = `${singular}s`;\n  }\n\n  return `${i || 0} ${i === 1 ? singular : plural}`;\n}\n/**\n * This function is a helper for turning arrays of breakpointMod objects for data toolbar and flex into classes\n *\n * @param {object} mods The modifiers object\n * @param {any} styles The appropriate styles object for the component\n */\n\nexport const formatBreakpointMods = (mods, styles) => Object.entries(mods || {}).map(([breakpoint, mod]) => `${mod}${breakpoint !== 'default' ? `-on-${breakpoint}` : ''}`).map(toCamel).map(mod => mod.replace(/-?(\\dxl)/gi, (_res, group) => `_${group}`)).map(modifierKey => styles.modifiers[modifierKey]).filter(Boolean).join(' ');\n\nconst camelize = s => s.toUpperCase().replace('-', '').replace('_', '');\n/**\n *\n * @param {string} s string to make camelCased\n */\n\n\nexport const toCamel = s => s.replace(/([-_][a-z])/gi, camelize);\n/**\n * Copied from exenv\n */\n\nexport const canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n/**\n * Calculate the width of the text\n * Example:\n * getTextWidth('my text', node)\n *\n * @param {string} text The text to calculate the width for\n * @param {HTMLElement} node The HTML element\n */\n\nexport const getTextWidth = (text, node) => {\n  const computedStyle = getComputedStyle(node); // Firefox returns the empty string for .font, so this function creates the .font property manually\n\n  const getFontFromComputedStyle = () => {\n    let computedFont = ''; // Firefox uses percentages for font-stretch, but Canvas does not accept percentages\n    // so convert to keywords, as listed at:\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/font-stretch\n\n    const fontStretchLookupTable = {\n      '50%': 'ultra-condensed',\n      '62.5%': 'extra-condensed',\n      '75%': 'condensed',\n      '87.5%': 'semi-condensed',\n      '100%': 'normal',\n      '112.5%': 'semi-expanded',\n      '125%': 'expanded',\n      '150%': 'extra-expanded',\n      '200%': 'ultra-expanded'\n    }; // If the retrieved font-stretch percentage isn't found in the lookup table, use\n    // 'normal' as a last resort.\n\n    let fontStretch;\n\n    if (computedStyle.fontStretch in fontStretchLookupTable) {\n      fontStretch = fontStretchLookupTable[computedStyle.fontStretch];\n    } else {\n      fontStretch = 'normal';\n    }\n\n    computedFont = computedStyle.fontStyle + ' ' + computedStyle.fontVariant + ' ' + computedStyle.fontWeight + ' ' + fontStretch + ' ' + computedStyle.fontSize + '/' + computedStyle.lineHeight + ' ' + computedStyle.fontFamily;\n    return computedFont;\n  };\n\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  context.font = computedStyle.font || getFontFromComputedStyle();\n  return context.measureText(text).width;\n};\n/**\n * Get the inner dimensions of an element\n *\n * @param {HTMLElement} node HTML element to calculate the inner dimensions for\n */\n\nexport const innerDimensions = node => {\n  const computedStyle = getComputedStyle(node);\n  let width = node.clientWidth; // width with padding\n\n  let height = node.clientHeight; // height with padding\n\n  height -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n  width -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  return {\n    height,\n    width\n  };\n};\n/**\n * This function is a helper for truncating text content on the left, leaving the right side of the content in view\n *\n * @param {HTMLElement} node HTML element\n * @param {string} value The original text value\n */\n\nexport const trimLeft = (node, value) => {\n  const availableWidth = innerDimensions(node).width;\n  let newValue = value;\n\n  if (getTextWidth(value, node) > availableWidth) {\n    // we have text overflow, trim the text to the left and add ... in the front until it fits\n    while (getTextWidth(`...${newValue}`, node) > availableWidth) {\n      newValue = newValue.substring(1);\n    } // replace text with our truncated text\n\n\n    if (node.value) {\n      node.value = `...${newValue}`;\n    } else {\n      node.innerText = `...${newValue}`;\n    }\n  } else {\n    if (node.value) {\n      node.value = value;\n    } else {\n      node.innerText = value;\n    }\n  }\n};\n/**\n * @param {string[]} events - Operations to prevent when disabled\n */\n\nexport const preventedEvents = events => events.reduce((handlers, eventToPrevent) => Object.assign(Object.assign({}, handlers), {\n  [eventToPrevent]: event => {\n    event.preventDefault();\n  }\n}), {});","map":{"version":3,"sources":["../../../src/helpers/util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as ReactDOM from 'react-dom';\nimport { SIDE } from './constants';\n/**\n * @param {string} input - String to capitalize first letter\n */\nexport function capitalize(input) {\n    return input[0].toUpperCase() + input.substring(1);\n}\n/**\n * @param {string} prefix - String to prefix ID with\n */\nexport function getUniqueId(prefix = 'pf') {\n    const uid = new Date().getTime() +\n        Math.random()\n            .toString(36)\n            .slice(2);\n    return `${prefix}-${uid}`;\n}\n/**\n * @param { any } this - \"This\" reference\n * @param { Function } func - Function to debounce\n * @param { number } wait - Debounce amount\n */\nexport function debounce(func, wait) {\n    let timeout;\n    return (...args) => {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => func.apply(this, args), wait);\n    };\n}\n/** This function returns whether or not an element is within the viewable area of a container. If partial is true,\n * then this function will return true even if only part of the element is in view.\n *\n * @param {HTMLElement} container  The container to check if the element is in view of.\n * @param {HTMLElement} element    The element to check if it is view\n * @param {boolean} partial   true if partial view is allowed\n *\n * @returns { boolean } True if the component is in View.\n */\nexport function isElementInView(container, element, partial) {\n    if (!container || !element) {\n        return false;\n    }\n    const containerBounds = container.getBoundingClientRect();\n    const elementBounds = element.getBoundingClientRect();\n    const containerBoundsLeft = Math.floor(containerBounds.left);\n    const containerBoundsRight = Math.floor(containerBounds.right);\n    const elementBoundsLeft = Math.floor(elementBounds.left);\n    const elementBoundsRight = Math.floor(elementBounds.right);\n    // Check if in view\n    const isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;\n    const isPartiallyInView = partial &&\n        ((elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft) ||\n            (elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight));\n    // Return outcome\n    return isTotallyInView || isPartiallyInView;\n}\n/** This function returns the side the element is out of view on (right, left or both)\n *\n * @param {HTMLElement} container    The container to check if the element is in view of.\n * @param {HTMLElement} element      The element to check if it is view\n *\n * @returns {string} right if the element is of the right, left if element is off the left or both if it is off on both sides.\n */\nexport function sideElementIsOutOfView(container, element) {\n    const containerBounds = container.getBoundingClientRect();\n    const elementBounds = element.getBoundingClientRect();\n    const containerBoundsLeft = Math.floor(containerBounds.left);\n    const containerBoundsRight = Math.floor(containerBounds.right);\n    const elementBoundsLeft = Math.floor(elementBounds.left);\n    const elementBoundsRight = Math.floor(elementBounds.right);\n    // Check if in view\n    const isOffLeft = elementBoundsLeft < containerBoundsLeft;\n    const isOffRight = elementBoundsRight > containerBoundsRight;\n    let side = SIDE.NONE;\n    if (isOffRight && isOffLeft) {\n        side = SIDE.BOTH;\n    }\n    else if (isOffRight) {\n        side = SIDE.RIGHT;\n    }\n    else if (isOffLeft) {\n        side = SIDE.LEFT;\n    }\n    // Return outcome\n    return side;\n}\n/** Interpolates a parameterized templateString using values from a templateVars object.\n * The templateVars object should have keys and values which match the templateString's parameters.\n * Example:\n *    const templateString: 'My name is ${firstName} ${lastName}';\n *    const templateVars: {\n *      firstName: 'Jon'\n *      lastName: 'Dough'\n *    };\n *    const result = fillTemplate(templateString, templateVars);\n *    // \"My name is Jon Dough\"\n *\n * @param {string} templateString  The string passed by the consumer\n * @param {object} templateVars The variables passed to the string\n *\n * @returns {string} The template string literal result\n */\nexport function fillTemplate(templateString, templateVars) {\n    return templateString.replace(/\\${(.*?)}/g, (_, match) => templateVars[match] || '');\n}\n/**\n * This function allows for keyboard navigation through dropdowns. The custom argument is optional.\n *\n * @param {number} index The index of the element you're on\n * @param {number} innerIndex Inner index number\n * @param {string} position The orientation of the dropdown\n * @param {string[]} refsCollection Array of refs to the items in the dropdown\n * @param {object[]} kids Array of items in the dropdown\n * @param {boolean} [custom] Allows for handling of flexible content\n */\nexport function keyHandler(index, innerIndex, position, refsCollection, kids, custom = false) {\n    if (!Array.isArray(kids)) {\n        return;\n    }\n    const isMultiDimensional = refsCollection.filter(ref => ref)[0].constructor === Array;\n    let nextIndex = index;\n    let nextInnerIndex = innerIndex;\n    if (position === 'up') {\n        if (index === 0) {\n            // loop back to end\n            nextIndex = kids.length - 1;\n        }\n        else {\n            nextIndex = index - 1;\n        }\n    }\n    else if (position === 'down') {\n        if (index === kids.length - 1) {\n            // loop back to beginning\n            nextIndex = 0;\n        }\n        else {\n            nextIndex = index + 1;\n        }\n    }\n    else if (position === 'left') {\n        if (innerIndex === 0) {\n            nextInnerIndex = refsCollection[index].length - 1;\n        }\n        else {\n            nextInnerIndex = innerIndex - 1;\n        }\n    }\n    else if (position === 'right') {\n        if (innerIndex === refsCollection[index].length - 1) {\n            nextInnerIndex = 0;\n        }\n        else {\n            nextInnerIndex = innerIndex + 1;\n        }\n    }\n    if (refsCollection[nextIndex] === null ||\n        refsCollection[nextIndex] === undefined ||\n        (isMultiDimensional &&\n            (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === undefined))) {\n        keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);\n    }\n    else if (custom) {\n        if (refsCollection[nextIndex].focus) {\n            refsCollection[nextIndex].focus();\n        }\n        // eslint-disable-next-line react/no-find-dom-node\n        const element = ReactDOM.findDOMNode(refsCollection[nextIndex]);\n        element.focus();\n    }\n    else if (position !== 'tab') {\n        if (isMultiDimensional) {\n            refsCollection[nextIndex][nextInnerIndex].focus();\n        }\n        else {\n            refsCollection[nextIndex].focus();\n        }\n    }\n}\n/** This function is a helper for keyboard navigation through dropdowns.\n *\n * @param {number} index The index of the element you're on\n * @param {string} position The orientation of the dropdown\n * @param {string[]} collection Array of refs to the items in the dropdown\n */\nexport function getNextIndex(index, position, collection) {\n    let nextIndex;\n    if (position === 'up') {\n        if (index === 0) {\n            // loop back to end\n            nextIndex = collection.length - 1;\n        }\n        else {\n            nextIndex = index - 1;\n        }\n    }\n    else if (index === collection.length - 1) {\n        // loop back to beginning\n        nextIndex = 0;\n    }\n    else {\n        nextIndex = index + 1;\n    }\n    if (collection[nextIndex] === undefined || collection[nextIndex][0] === null) {\n        return getNextIndex(nextIndex, position, collection);\n    }\n    else {\n        return nextIndex;\n    }\n}\n/** This function is a helper for pluralizing strings.\n *\n * @param {number} i The quantity of the string you want to pluralize\n * @param {string} singular The singular version of the string\n * @param {string} plural The change to the string that should occur if the quantity is not equal to 1.\n *                 Defaults to adding an 's'.\n */\nexport function pluralize(i, singular, plural) {\n    if (!plural) {\n        plural = `${singular}s`;\n    }\n    return `${i || 0} ${i === 1 ? singular : plural}`;\n}\n/**\n * This function is a helper for turning arrays of breakpointMod objects for data toolbar and flex into classes\n *\n * @param {object} mods The modifiers object\n * @param {any} styles The appropriate styles object for the component\n */\nexport const formatBreakpointMods = (mods, styles) => Object.entries(mods || {})\n    .map(([breakpoint, mod]) => `${mod}${breakpoint !== 'default' ? `-on-${breakpoint}` : ''}`)\n    .map(toCamel)\n    .map(mod => mod.replace(/-?(\\dxl)/gi, (_res, group) => `_${group}`))\n    .map(modifierKey => styles.modifiers[modifierKey])\n    .filter(Boolean)\n    .join(' ');\nconst camelize = (s) => s\n    .toUpperCase()\n    .replace('-', '')\n    .replace('_', '');\n/**\n *\n * @param {string} s string to make camelCased\n */\nexport const toCamel = (s) => s.replace(/([-_][a-z])/gi, camelize);\n/**\n * Copied from exenv\n */\nexport const canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n/**\n * Calculate the width of the text\n * Example:\n * getTextWidth('my text', node)\n *\n * @param {string} text The text to calculate the width for\n * @param {HTMLElement} node The HTML element\n */\nexport const getTextWidth = (text, node) => {\n    const computedStyle = getComputedStyle(node);\n    // Firefox returns the empty string for .font, so this function creates the .font property manually\n    const getFontFromComputedStyle = () => {\n        let computedFont = '';\n        // Firefox uses percentages for font-stretch, but Canvas does not accept percentages\n        // so convert to keywords, as listed at:\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/font-stretch\n        const fontStretchLookupTable = {\n            '50%': 'ultra-condensed',\n            '62.5%': 'extra-condensed',\n            '75%': 'condensed',\n            '87.5%': 'semi-condensed',\n            '100%': 'normal',\n            '112.5%': 'semi-expanded',\n            '125%': 'expanded',\n            '150%': 'extra-expanded',\n            '200%': 'ultra-expanded'\n        };\n        // If the retrieved font-stretch percentage isn't found in the lookup table, use\n        // 'normal' as a last resort.\n        let fontStretch;\n        if (computedStyle.fontStretch in fontStretchLookupTable) {\n            fontStretch = fontStretchLookupTable[computedStyle.fontStretch];\n        }\n        else {\n            fontStretch = 'normal';\n        }\n        computedFont =\n            computedStyle.fontStyle +\n                ' ' +\n                computedStyle.fontVariant +\n                ' ' +\n                computedStyle.fontWeight +\n                ' ' +\n                fontStretch +\n                ' ' +\n                computedStyle.fontSize +\n                '/' +\n                computedStyle.lineHeight +\n                ' ' +\n                computedStyle.fontFamily;\n        return computedFont;\n    };\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    context.font = computedStyle.font || getFontFromComputedStyle();\n    return context.measureText(text).width;\n};\n/**\n * Get the inner dimensions of an element\n *\n * @param {HTMLElement} node HTML element to calculate the inner dimensions for\n */\nexport const innerDimensions = (node) => {\n    const computedStyle = getComputedStyle(node);\n    let width = node.clientWidth; // width with padding\n    let height = node.clientHeight; // height with padding\n    height -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n    width -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n    return { height, width };\n};\n/**\n * This function is a helper for truncating text content on the left, leaving the right side of the content in view\n *\n * @param {HTMLElement} node HTML element\n * @param {string} value The original text value\n */\nexport const trimLeft = (node, value) => {\n    const availableWidth = innerDimensions(node).width;\n    let newValue = value;\n    if (getTextWidth(value, node) > availableWidth) {\n        // we have text overflow, trim the text to the left and add ... in the front until it fits\n        while (getTextWidth(`...${newValue}`, node) > availableWidth) {\n            newValue = newValue.substring(1);\n        }\n        // replace text with our truncated text\n        if (node.value) {\n            node.value = `...${newValue}`;\n        }\n        else {\n            node.innerText = `...${newValue}`;\n        }\n    }\n    else {\n        if (node.value) {\n            node.value = value;\n        }\n        else {\n            node.innerText = value;\n        }\n    }\n};\n/**\n * @param {string[]} events - Operations to prevent when disabled\n */\nexport const preventedEvents = (events) => events.reduce((handlers, eventToPrevent) => (Object.assign(Object.assign({}, handlers), { [eventToPrevent]: (event) => {\n        event.preventDefault();\n    } })), {});\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"module"}