{"ast":null,"code":"import getBoundingClientRect from '../dom-utils/getBoundingClientRect';\nimport getClippingRect from '../dom-utils/getClippingRect';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport computeOffsets from './computeOffsets';\nimport rectToClientRect from './rectToClientRect';\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from '../enums';\nimport { isElement } from '../dom-utils/instanceOf';\nimport mergePaddingObject from './mergePaddingObject';\nimport expandToHashMap from './expandToHashMap';\n/**\n * @param state\n * @param options\n */\n\nexport default function detectOverflow(state, options = {}) {\n  const {\n    placement = state.placement,\n    boundary = clippingParents,\n    rootBoundary = viewport,\n    elementContext = popper,\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  const altContext = elementContext === popper ? reference : popper;\n  const referenceElement = state.elements.reference;\n  const popperRect = state.rects.popper;\n  const element = state.elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n  const referenceClientRect = getBoundingClientRect(referenceElement);\n  const popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement\n  });\n  const popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets));\n  const elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  const overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  const offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === popper && offsetData) {\n    const offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(key => {\n      const multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      const axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}","map":{"version":3,"sources":["../../../../../../../src/helpers/Popper/thirdparty/popper-core/utils/detectOverflow.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import getBoundingClientRect from '../dom-utils/getBoundingClientRect';\nimport getClippingRect from '../dom-utils/getClippingRect';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport computeOffsets from './computeOffsets';\nimport rectToClientRect from './rectToClientRect';\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from '../enums';\nimport { isElement } from '../dom-utils/instanceOf';\nimport mergePaddingObject from './mergePaddingObject';\nimport expandToHashMap from './expandToHashMap';\n/**\n * @param state\n * @param options\n */\nexport default function detectOverflow(state, options = {}) {\n    const { placement = state.placement, boundary = clippingParents, rootBoundary = viewport, elementContext = popper, altBoundary = false, padding = 0 } = options;\n    const paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n    const altContext = elementContext === popper ? reference : popper;\n    const referenceElement = state.elements.reference;\n    const popperRect = state.rects.popper;\n    const element = state.elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n    const referenceClientRect = getBoundingClientRect(referenceElement);\n    const popperOffsets = computeOffsets({\n        reference: referenceClientRect,\n        element: popperRect,\n        strategy: 'absolute',\n        placement\n    });\n    const popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets));\n    const elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;\n    // positive = overflowing the clipping rect\n    // 0 or negative = within the clipping rect\n    const overflowOffsets = {\n        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n        right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    const offsetData = state.modifiersData.offset;\n    // Offsets can be applied only to the popper element\n    if (elementContext === popper && offsetData) {\n        const offset = offsetData[placement];\n        Object.keys(overflowOffsets).forEach(key => {\n            const multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n            const axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n            overflowOffsets[key] += offset[axis] * multiply;\n        });\n    }\n    return overflowOffsets;\n}\n//# sourceMappingURL=detectOverflow.js.map"]},"metadata":{},"sourceType":"module"}