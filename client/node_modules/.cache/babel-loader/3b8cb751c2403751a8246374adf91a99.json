{"ast":null,"code":"import getBasePlacement from '../utils/getBasePlacement';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport contains from '../dom-utils/contains';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport within from '../utils/within';\nimport mergePaddingObject from '../utils/mergePaddingObject';\nimport expandToHashMap from '../utils/expandToHashMap';\nimport { left, right, basePlacements, top, bottom } from '../enums';\nimport { isHTMLElement } from '../dom-utils/instanceOf';\n/**\n *\n */\n\nfunction arrow({\n  state,\n  name\n}) {\n  const arrowElement = state.elements.arrow;\n  const popperOffsets = state.modifiersData.popperOffsets;\n  const basePlacement = getBasePlacement(state.placement);\n  const axis = getMainAxisFromPlacement(basePlacement);\n  const isVertical = [left, right].indexOf(basePlacement) >= 0;\n  const len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  const paddingObject = state.modifiersData[`${name}#persistent`].padding;\n  const arrowRect = getLayoutRect(arrowElement);\n  const minProp = axis === 'y' ? top : left;\n  const maxProp = axis === 'y' ? bottom : right;\n  const endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  const startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  const arrowOffsetParent = getOffsetParent(arrowElement);\n  const clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  const min = paddingObject[minProp];\n  const max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  const center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  const offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n  const axisProp = axis;\n  state.modifiersData[name] = {\n    [axisProp]: offset,\n    centerOffset: offset - center\n  };\n}\n/**\n *\n */\n\n\nfunction effect({\n  state,\n  options,\n  name\n}) {\n  let {\n    element: arrowElement = '[data-popper-arrow]',\n    padding = 0\n  } = options;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (false\n  /* __DEV__*/\n  ) {\n      if (!isHTMLElement(arrowElement)) {\n        console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));\n      }\n    }\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    if (false\n    /* __DEV__*/\n    ) {\n        console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', 'element.'].join(' '));\n      }\n\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n  state.modifiersData[`${name}#persistent`] = {\n    padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))\n  };\n}\n\nexport default {\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n};","map":{"version":3,"sources":["../../../../../../../src/helpers/Popper/thirdparty/popper-core/modifiers/arrow.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import getBasePlacement from '../utils/getBasePlacement';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport contains from '../dom-utils/contains';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport within from '../utils/within';\nimport mergePaddingObject from '../utils/mergePaddingObject';\nimport expandToHashMap from '../utils/expandToHashMap';\nimport { left, right, basePlacements, top, bottom } from '../enums';\nimport { isHTMLElement } from '../dom-utils/instanceOf';\n/**\n *\n */\nfunction arrow({ state, name }) {\n    const arrowElement = state.elements.arrow;\n    const popperOffsets = state.modifiersData.popperOffsets;\n    const basePlacement = getBasePlacement(state.placement);\n    const axis = getMainAxisFromPlacement(basePlacement);\n    const isVertical = [left, right].indexOf(basePlacement) >= 0;\n    const len = isVertical ? 'height' : 'width';\n    if (!arrowElement || !popperOffsets) {\n        return;\n    }\n    const paddingObject = state.modifiersData[`${name}#persistent`].padding;\n    const arrowRect = getLayoutRect(arrowElement);\n    const minProp = axis === 'y' ? top : left;\n    const maxProp = axis === 'y' ? bottom : right;\n    const endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n    const startDiff = popperOffsets[axis] - state.rects.reference[axis];\n    const arrowOffsetParent = getOffsetParent(arrowElement);\n    const clientSize = arrowOffsetParent\n        ? axis === 'y'\n            ? arrowOffsetParent.clientHeight || 0\n            : arrowOffsetParent.clientWidth || 0\n        : 0;\n    const centerToReference = endDiff / 2 - startDiff / 2;\n    // Make sure the arrow doesn't overflow the popper if the center point is\n    // outside of the popper bounds\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowRect[len] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    const offset = within(min, center, max);\n    // Prevents breaking syntax highlighting...\n    const axisProp = axis;\n    state.modifiersData[name] = {\n        [axisProp]: offset,\n        centerOffset: offset - center\n    };\n}\n/**\n *\n */\nfunction effect({ state, options, name }) {\n    let { element: arrowElement = '[data-popper-arrow]', padding = 0 } = options;\n    if (arrowElement == null) {\n        return;\n    }\n    // CSS selector\n    if (typeof arrowElement === 'string') {\n        arrowElement = state.elements.popper.querySelector(arrowElement);\n        if (!arrowElement) {\n            return;\n        }\n    }\n    if (false /* __DEV__*/) {\n        if (!isHTMLElement(arrowElement)) {\n            console.error([\n                'Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).',\n                'To use an SVG arrow, wrap it in an HTMLElement that will be used as',\n                'the arrow.'\n            ].join(' '));\n        }\n    }\n    if (!contains(state.elements.popper, arrowElement)) {\n        if (false /* __DEV__*/) {\n            console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', 'element.'].join(' '));\n        }\n        return;\n    }\n    state.elements.arrow = arrowElement;\n    state.modifiersData[`${name}#persistent`] = {\n        padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))\n    };\n}\nexport default {\n    name: 'arrow',\n    enabled: true,\n    phase: 'main',\n    fn: arrow,\n    effect,\n    requires: ['popperOffsets'],\n    requiresIfExists: ['preventOverflow']\n};\n//# sourceMappingURL=arrow.js.map"]},"metadata":{},"sourceType":"module"}